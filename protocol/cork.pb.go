// Code generated by protoc-gen-go.
// source: cork.proto
// DO NOT EDIT!

/*
Package cork is a generated protocol buffer package.

It is generated from these files:
	cork.proto

It has these top-level messages:
	Empty
	Response
	KillRequest
	StatusRequest
	ExecuteEvent
	EndEvent
	ErrorEvent
	ExportEvent
	OutputEvent
	StepExecuteRequest
	Step
	StepListResponse
	VolumesToMountGetResponse
	StageExecuteRequest
	EventReactRequest
*/
package cork

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Response struct {
	Status uint32 `protobuf:"varint,1,opt,name=status" json:"status,omitempty"`
	// Types that are valid to be assigned to Res:
	//	*Response_Empty
	//	*Response_Steps
	//	*Response_Volumes
	Res isResponse_Res `protobuf_oneof:"res"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isResponse_Res interface {
	isResponse_Res()
}

type Response_Empty struct {
	Empty *Empty `protobuf:"bytes,2,opt,name=empty,oneof"`
}
type Response_Steps struct {
	Steps *StepListResponse `protobuf:"bytes,3,opt,name=steps,oneof"`
}
type Response_Volumes struct {
	Volumes *VolumesToMountGetResponse `protobuf:"bytes,4,opt,name=volumes,oneof"`
}

func (*Response_Empty) isResponse_Res()   {}
func (*Response_Steps) isResponse_Res()   {}
func (*Response_Volumes) isResponse_Res() {}

func (m *Response) GetRes() isResponse_Res {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *Response) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Response) GetEmpty() *Empty {
	if x, ok := m.GetRes().(*Response_Empty); ok {
		return x.Empty
	}
	return nil
}

func (m *Response) GetSteps() *StepListResponse {
	if x, ok := m.GetRes().(*Response_Steps); ok {
		return x.Steps
	}
	return nil
}

func (m *Response) GetVolumes() *VolumesToMountGetResponse {
	if x, ok := m.GetRes().(*Response_Volumes); ok {
		return x.Volumes
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Response) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Response_OneofMarshaler, _Response_OneofUnmarshaler, _Response_OneofSizer, []interface{}{
		(*Response_Empty)(nil),
		(*Response_Steps)(nil),
		(*Response_Volumes)(nil),
	}
}

func _Response_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Response)
	// res
	switch x := m.Res.(type) {
	case *Response_Empty:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Empty); err != nil {
			return err
		}
	case *Response_Steps:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Steps); err != nil {
			return err
		}
	case *Response_Volumes:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Volumes); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Response.Res has unexpected type %T", x)
	}
	return nil
}

func _Response_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Response)
	switch tag {
	case 2: // res.empty
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.Res = &Response_Empty{msg}
		return true, err
	case 3: // res.steps
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StepListResponse)
		err := b.DecodeMessage(msg)
		m.Res = &Response_Steps{msg}
		return true, err
	case 4: // res.volumes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VolumesToMountGetResponse)
		err := b.DecodeMessage(msg)
		m.Res = &Response_Volumes{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Response_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Response)
	// res
	switch x := m.Res.(type) {
	case *Response_Empty:
		s := proto.Size(x.Empty)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Response_Steps:
		s := proto.Size(x.Steps)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Response_Volumes:
		s := proto.Size(x.Volumes)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type KillRequest struct {
}

func (m *KillRequest) Reset()                    { *m = KillRequest{} }
func (m *KillRequest) String() string            { return proto.CompactTextString(m) }
func (*KillRequest) ProtoMessage()               {}
func (*KillRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type StatusRequest struct {
}

func (m *StatusRequest) Reset()                    { *m = StatusRequest{} }
func (m *StatusRequest) String() string            { return proto.CompactTextString(m) }
func (*StatusRequest) ProtoMessage()               {}
func (*StatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type ExecuteEvent struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Types that are valid to be assigned to Body:
	//	*ExecuteEvent_Empty
	//	*ExecuteEvent_End
	//	*ExecuteEvent_Output
	//	*ExecuteEvent_Export
	//	*ExecuteEvent_Error
	Body isExecuteEvent_Body `protobuf_oneof:"body"`
}

func (m *ExecuteEvent) Reset()                    { *m = ExecuteEvent{} }
func (m *ExecuteEvent) String() string            { return proto.CompactTextString(m) }
func (*ExecuteEvent) ProtoMessage()               {}
func (*ExecuteEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isExecuteEvent_Body interface {
	isExecuteEvent_Body()
}

type ExecuteEvent_Empty struct {
	Empty *Empty `protobuf:"bytes,2,opt,name=empty,oneof"`
}
type ExecuteEvent_End struct {
	End *EndEvent `protobuf:"bytes,3,opt,name=end,oneof"`
}
type ExecuteEvent_Output struct {
	Output *OutputEvent `protobuf:"bytes,4,opt,name=output,oneof"`
}
type ExecuteEvent_Export struct {
	Export *ExportEvent `protobuf:"bytes,5,opt,name=export,oneof"`
}
type ExecuteEvent_Error struct {
	Error *ErrorEvent `protobuf:"bytes,6,opt,name=error,oneof"`
}

func (*ExecuteEvent_Empty) isExecuteEvent_Body()  {}
func (*ExecuteEvent_End) isExecuteEvent_Body()    {}
func (*ExecuteEvent_Output) isExecuteEvent_Body() {}
func (*ExecuteEvent_Export) isExecuteEvent_Body() {}
func (*ExecuteEvent_Error) isExecuteEvent_Body()  {}

func (m *ExecuteEvent) GetBody() isExecuteEvent_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ExecuteEvent) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ExecuteEvent) GetEmpty() *Empty {
	if x, ok := m.GetBody().(*ExecuteEvent_Empty); ok {
		return x.Empty
	}
	return nil
}

func (m *ExecuteEvent) GetEnd() *EndEvent {
	if x, ok := m.GetBody().(*ExecuteEvent_End); ok {
		return x.End
	}
	return nil
}

func (m *ExecuteEvent) GetOutput() *OutputEvent {
	if x, ok := m.GetBody().(*ExecuteEvent_Output); ok {
		return x.Output
	}
	return nil
}

func (m *ExecuteEvent) GetExport() *ExportEvent {
	if x, ok := m.GetBody().(*ExecuteEvent_Export); ok {
		return x.Export
	}
	return nil
}

func (m *ExecuteEvent) GetError() *ErrorEvent {
	if x, ok := m.GetBody().(*ExecuteEvent_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ExecuteEvent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ExecuteEvent_OneofMarshaler, _ExecuteEvent_OneofUnmarshaler, _ExecuteEvent_OneofSizer, []interface{}{
		(*ExecuteEvent_Empty)(nil),
		(*ExecuteEvent_End)(nil),
		(*ExecuteEvent_Output)(nil),
		(*ExecuteEvent_Export)(nil),
		(*ExecuteEvent_Error)(nil),
	}
}

func _ExecuteEvent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ExecuteEvent)
	// body
	switch x := m.Body.(type) {
	case *ExecuteEvent_Empty:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Empty); err != nil {
			return err
		}
	case *ExecuteEvent_End:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.End); err != nil {
			return err
		}
	case *ExecuteEvent_Output:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Output); err != nil {
			return err
		}
	case *ExecuteEvent_Export:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Export); err != nil {
			return err
		}
	case *ExecuteEvent_Error:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ExecuteEvent.Body has unexpected type %T", x)
	}
	return nil
}

func _ExecuteEvent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ExecuteEvent)
	switch tag {
	case 2: // body.empty
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.Body = &ExecuteEvent_Empty{msg}
		return true, err
	case 3: // body.end
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndEvent)
		err := b.DecodeMessage(msg)
		m.Body = &ExecuteEvent_End{msg}
		return true, err
	case 4: // body.output
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OutputEvent)
		err := b.DecodeMessage(msg)
		m.Body = &ExecuteEvent_Output{msg}
		return true, err
	case 5: // body.export
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExportEvent)
		err := b.DecodeMessage(msg)
		m.Body = &ExecuteEvent_Export{msg}
		return true, err
	case 6: // body.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ErrorEvent)
		err := b.DecodeMessage(msg)
		m.Body = &ExecuteEvent_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ExecuteEvent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ExecuteEvent)
	// body
	switch x := m.Body.(type) {
	case *ExecuteEvent_Empty:
		s := proto.Size(x.Empty)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ExecuteEvent_End:
		s := proto.Size(x.End)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ExecuteEvent_Output:
		s := proto.Size(x.Output)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ExecuteEvent_Export:
		s := proto.Size(x.Export)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ExecuteEvent_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EndEvent struct {
	Tags []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
}

func (m *EndEvent) Reset()                    { *m = EndEvent{} }
func (m *EndEvent) String() string            { return proto.CompactTextString(m) }
func (*EndEvent) ProtoMessage()               {}
func (*EndEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *EndEvent) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ErrorEvent struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *ErrorEvent) Reset()                    { *m = ErrorEvent{} }
func (m *ErrorEvent) String() string            { return proto.CompactTextString(m) }
func (*ErrorEvent) ProtoMessage()               {}
func (*ErrorEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ErrorEvent) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ExportEvent struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *ExportEvent) Reset()                    { *m = ExportEvent{} }
func (m *ExportEvent) String() string            { return proto.CompactTextString(m) }
func (*ExportEvent) ProtoMessage()               {}
func (*ExportEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ExportEvent) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExportEvent) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type OutputEvent struct {
	Bytes  []byte `protobuf:"bytes,1,opt,name=bytes,proto3" json:"bytes,omitempty"`
	Stream string `protobuf:"bytes,2,opt,name=stream" json:"stream,omitempty"`
}

func (m *OutputEvent) Reset()                    { *m = OutputEvent{} }
func (m *OutputEvent) String() string            { return proto.CompactTextString(m) }
func (*OutputEvent) ProtoMessage()               {}
func (*OutputEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *OutputEvent) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

func (m *OutputEvent) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

type StepExecuteRequest struct {
	StepName string `protobuf:"bytes,1,opt,name=stepName" json:"stepName,omitempty"`
}

func (m *StepExecuteRequest) Reset()                    { *m = StepExecuteRequest{} }
func (m *StepExecuteRequest) String() string            { return proto.CompactTextString(m) }
func (*StepExecuteRequest) ProtoMessage()               {}
func (*StepExecuteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *StepExecuteRequest) GetStepName() string {
	if m != nil {
		return m.StepName
	}
	return ""
}

type Step struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Step) Reset()                    { *m = Step{} }
func (m *Step) String() string            { return proto.CompactTextString(m) }
func (*Step) ProtoMessage()               {}
func (*Step) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Step) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type StepListResponse struct {
	Step []*Step `protobuf:"bytes,1,rep,name=step" json:"step,omitempty"`
}

func (m *StepListResponse) Reset()                    { *m = StepListResponse{} }
func (m *StepListResponse) String() string            { return proto.CompactTextString(m) }
func (*StepListResponse) ProtoMessage()               {}
func (*StepListResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *StepListResponse) GetStep() []*Step {
	if m != nil {
		return m.Step
	}
	return nil
}

type VolumesToMountGetResponse struct {
	Volumes []string `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
}

func (m *VolumesToMountGetResponse) Reset()                    { *m = VolumesToMountGetResponse{} }
func (m *VolumesToMountGetResponse) String() string            { return proto.CompactTextString(m) }
func (*VolumesToMountGetResponse) ProtoMessage()               {}
func (*VolumesToMountGetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *VolumesToMountGetResponse) GetVolumes() []string {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type StageExecuteRequest struct {
	Stage string `protobuf:"bytes,1,opt,name=stage" json:"stage,omitempty"`
}

func (m *StageExecuteRequest) Reset()                    { *m = StageExecuteRequest{} }
func (m *StageExecuteRequest) String() string            { return proto.CompactTextString(m) }
func (*StageExecuteRequest) ProtoMessage()               {}
func (*StageExecuteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *StageExecuteRequest) GetStage() string {
	if m != nil {
		return m.Stage
	}
	return ""
}

type EventReactRequest struct {
	Project string            `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	Tags    []string          `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
	Outputs map[string]string `protobuf:"bytes,3,rep,name=outputs" json:"outputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EventReactRequest) Reset()                    { *m = EventReactRequest{} }
func (m *EventReactRequest) String() string            { return proto.CompactTextString(m) }
func (*EventReactRequest) ProtoMessage()               {}
func (*EventReactRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *EventReactRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *EventReactRequest) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *EventReactRequest) GetOutputs() map[string]string {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "Empty")
	proto.RegisterType((*Response)(nil), "Response")
	proto.RegisterType((*KillRequest)(nil), "KillRequest")
	proto.RegisterType((*StatusRequest)(nil), "StatusRequest")
	proto.RegisterType((*ExecuteEvent)(nil), "ExecuteEvent")
	proto.RegisterType((*EndEvent)(nil), "EndEvent")
	proto.RegisterType((*ErrorEvent)(nil), "ErrorEvent")
	proto.RegisterType((*ExportEvent)(nil), "ExportEvent")
	proto.RegisterType((*OutputEvent)(nil), "OutputEvent")
	proto.RegisterType((*StepExecuteRequest)(nil), "StepExecuteRequest")
	proto.RegisterType((*Step)(nil), "Step")
	proto.RegisterType((*StepListResponse)(nil), "StepListResponse")
	proto.RegisterType((*VolumesToMountGetResponse)(nil), "VolumesToMountGetResponse")
	proto.RegisterType((*StageExecuteRequest)(nil), "StageExecuteRequest")
	proto.RegisterType((*EventReactRequest)(nil), "EventReactRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CorkTypeService service

type CorkTypeServiceClient interface {
	// Status endpoint
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Response, error)
	// Kills the cork server
	Kill(ctx context.Context, in *KillRequest, opts ...grpc.CallOption) (*Response, error)
	// Executes a specific stage
	StageExecute(ctx context.Context, in *StageExecuteRequest, opts ...grpc.CallOption) (CorkTypeService_StageExecuteClient, error)
	// React to an event
	EventReact(ctx context.Context, in *EventReactRequest, opts ...grpc.CallOption) (*Response, error)
}

type corkTypeServiceClient struct {
	cc *grpc.ClientConn
}

func NewCorkTypeServiceClient(cc *grpc.ClientConn) CorkTypeServiceClient {
	return &corkTypeServiceClient{cc}
}

func (c *corkTypeServiceClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/CorkTypeService/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *corkTypeServiceClient) Kill(ctx context.Context, in *KillRequest, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/CorkTypeService/Kill", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *corkTypeServiceClient) StageExecute(ctx context.Context, in *StageExecuteRequest, opts ...grpc.CallOption) (CorkTypeService_StageExecuteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CorkTypeService_serviceDesc.Streams[0], c.cc, "/CorkTypeService/StageExecute", opts...)
	if err != nil {
		return nil, err
	}
	x := &corkTypeServiceStageExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CorkTypeService_StageExecuteClient interface {
	Recv() (*ExecuteEvent, error)
	grpc.ClientStream
}

type corkTypeServiceStageExecuteClient struct {
	grpc.ClientStream
}

func (x *corkTypeServiceStageExecuteClient) Recv() (*ExecuteEvent, error) {
	m := new(ExecuteEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *corkTypeServiceClient) EventReact(ctx context.Context, in *EventReactRequest, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/CorkTypeService/EventReact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CorkTypeService service

type CorkTypeServiceServer interface {
	// Status endpoint
	Status(context.Context, *StatusRequest) (*Response, error)
	// Kills the cork server
	Kill(context.Context, *KillRequest) (*Response, error)
	// Executes a specific stage
	StageExecute(*StageExecuteRequest, CorkTypeService_StageExecuteServer) error
	// React to an event
	EventReact(context.Context, *EventReactRequest) (*Response, error)
}

func RegisterCorkTypeServiceServer(s *grpc.Server, srv CorkTypeServiceServer) {
	s.RegisterService(&_CorkTypeService_serviceDesc, srv)
}

func _CorkTypeService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CorkTypeServiceServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CorkTypeService/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CorkTypeServiceServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CorkTypeService_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CorkTypeServiceServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CorkTypeService/Kill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CorkTypeServiceServer).Kill(ctx, req.(*KillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CorkTypeService_StageExecute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StageExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CorkTypeServiceServer).StageExecute(m, &corkTypeServiceStageExecuteServer{stream})
}

type CorkTypeService_StageExecuteServer interface {
	Send(*ExecuteEvent) error
	grpc.ServerStream
}

type corkTypeServiceStageExecuteServer struct {
	grpc.ServerStream
}

func (x *corkTypeServiceStageExecuteServer) Send(m *ExecuteEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _CorkTypeService_EventReact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventReactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CorkTypeServiceServer).EventReact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CorkTypeService/EventReact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CorkTypeServiceServer).EventReact(ctx, req.(*EventReactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CorkTypeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "CorkTypeService",
	HandlerType: (*CorkTypeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _CorkTypeService_Status_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _CorkTypeService_Kill_Handler,
		},
		{
			MethodName: "EventReact",
			Handler:    _CorkTypeService_EventReact_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StageExecute",
			Handler:       _CorkTypeService_StageExecute_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cork.proto",
}

func init() { proto.RegisterFile("cork.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 610 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0x8d, 0x9b, 0xd8, 0x69, 0x26, 0xc9, 0xd7, 0x76, 0xbf, 0x0a, 0xb9, 0x96, 0x28, 0x65, 0x11,
	0x55, 0x11, 0xea, 0xaa, 0x2a, 0x82, 0x42, 0xb9, 0x2b, 0xb2, 0xa8, 0xc4, 0x9f, 0xe4, 0x54, 0xdc,
	0xbb, 0xe9, 0x28, 0x2a, 0x4d, 0xbc, 0x66, 0x77, 0x1d, 0xd5, 0xef, 0xc4, 0x03, 0x70, 0xcf, 0x7b,
	0xf0, 0x2c, 0x68, 0xff, 0x12, 0xf7, 0x07, 0x71, 0xb7, 0x67, 0xe7, 0xcc, 0x7a, 0xe6, 0xcc, 0x19,
	0x03, 0x8c, 0xb9, 0xb8, 0x62, 0xa5, 0xe0, 0x8a, 0xd3, 0x2e, 0x84, 0xe9, 0xac, 0x54, 0x35, 0xfd,
	0x11, 0xc0, 0x6a, 0x86, 0xb2, 0xe4, 0x85, 0x44, 0xf2, 0x00, 0x22, 0xa9, 0x72, 0x55, 0xc9, 0x38,
	0xd8, 0x09, 0xf6, 0x86, 0x99, 0x43, 0x64, 0x1b, 0x42, 0xd4, 0xec, 0x78, 0x65, 0x27, 0xd8, 0xeb,
	0x1f, 0x46, 0xcc, 0xe4, 0x9e, 0xb6, 0x32, 0x7b, 0x4d, 0x9e, 0x41, 0x28, 0x15, 0x96, 0x32, 0x6e,
	0x9b, 0xf8, 0x06, 0x1b, 0x29, 0x2c, 0x3f, 0x5e, 0x4a, 0xe5, 0x5f, 0xd6, 0x54, 0xc3, 0x20, 0xaf,
	0xa0, 0x3b, 0xe7, 0xd3, 0x6a, 0x86, 0x32, 0xee, 0x18, 0x72, 0xc2, 0xbe, 0x5a, 0x7c, 0xc6, 0x3f,
	0xf1, 0xaa, 0x50, 0xef, 0xb1, 0x99, 0xe5, 0xc9, 0x27, 0x21, 0xb4, 0x05, 0x4a, 0x3a, 0x84, 0xfe,
	0x87, 0xcb, 0xe9, 0x34, 0xc3, 0xef, 0x15, 0x4a, 0x45, 0xd7, 0x60, 0x38, 0x32, 0x25, 0xfa, 0x8b,
	0xdf, 0x01, 0x0c, 0xd2, 0x6b, 0x1c, 0x57, 0x0a, 0xd3, 0x39, 0x16, 0x8a, 0x10, 0xe8, 0xa8, 0xba,
	0x44, 0xd3, 0x50, 0x2f, 0x33, 0xe7, 0x7f, 0xb6, 0xf3, 0x10, 0xda, 0x58, 0x5c, 0xb8, 0x66, 0x7a,
	0x2c, 0x2d, 0x2e, 0xcc, 0x5b, 0xa7, 0xad, 0x4c, 0xdf, 0x93, 0x5d, 0x88, 0x78, 0xa5, 0xca, 0x4a,
	0xb9, 0x0e, 0x06, 0xec, 0x8b, 0x81, 0x9e, 0xe4, 0xa2, 0x9a, 0x87, 0xd7, 0x25, 0x17, 0x2a, 0x0e,
	0x1d, 0x2f, 0x35, 0x70, 0xc1, 0xb3, 0x51, 0xf2, 0x04, 0x42, 0x14, 0x82, 0x8b, 0x38, 0x32, 0xb4,
	0x3e, 0x4b, 0x35, 0xf2, 0x2c, 0x1b, 0x3b, 0x89, 0xa0, 0x73, 0xce, 0x2f, 0x6a, 0xba, 0x0d, 0xab,
	0xbe, 0x1e, 0xd3, 0x5b, 0x3e, 0xd1, 0xc3, 0x6a, 0x9b, 0xde, 0xf2, 0x89, 0xa4, 0xbb, 0x00, 0xcb,
	0x74, 0x12, 0x43, 0x77, 0x86, 0x52, 0xe6, 0x13, 0x2f, 0x80, 0x87, 0xf4, 0x08, 0xfa, 0x8d, 0x6a,
	0xf4, 0x53, 0x45, 0x3e, 0x5b, 0xc8, 0xa4, 0xcf, 0x64, 0x13, 0xc2, 0x79, 0x3e, 0xad, 0xd0, 0xc8,
	0xd4, 0xcb, 0x2c, 0xa0, 0x6f, 0xa1, 0xdf, 0x68, 0x57, 0x93, 0xce, 0x6b, 0x85, 0xd6, 0x31, 0x83,
	0xcc, 0x02, 0x6b, 0x24, 0x81, 0xf9, 0xcc, 0xe5, 0x3a, 0x44, 0x0f, 0x80, 0x68, 0x6b, 0xb8, 0x09,
	0xb9, 0xa1, 0x91, 0x04, 0x56, 0xb5, 0x39, 0x3e, 0x2f, 0x0b, 0x58, 0x60, 0x9a, 0x40, 0x47, 0x67,
	0xdc, 0x57, 0x20, 0xdd, 0x87, 0xf5, 0xdb, 0x46, 0x23, 0x5b, 0xd0, 0xd1, 0xb9, 0x46, 0x93, 0xfe,
	0x61, 0x68, 0x9c, 0x98, 0x99, 0x2b, 0xfa, 0x12, 0xb6, 0xfe, 0x6a, 0x35, 0xad, 0x94, 0xf7, 0xa5,
	0x95, 0xd3, 0x43, 0xfa, 0x1c, 0xfe, 0x1f, 0xa9, 0x7c, 0x82, 0xb7, 0x8a, 0xde, 0xd4, 0x9e, 0x5f,
	0x0a, 0x6b, 0x01, 0xfd, 0x19, 0xc0, 0x86, 0x11, 0x26, 0xc3, 0x7c, 0xac, 0x3c, 0x37, 0x86, 0x6e,
	0x29, 0xf8, 0x37, 0x1c, 0x2b, 0x3f, 0x06, 0x07, 0x17, 0x23, 0x5c, 0x59, 0x8e, 0x90, 0xbc, 0x81,
	0xae, 0x75, 0x90, 0xde, 0x27, 0xdd, 0xc5, 0x23, 0x76, 0xe7, 0x49, 0x67, 0x39, 0x99, 0x16, 0x4a,
	0xd4, 0x99, 0xe7, 0x27, 0xc7, 0x30, 0x68, 0x06, 0xc8, 0x3a, 0xb4, 0xaf, 0xb0, 0x76, 0x1f, 0xd5,
	0xc7, 0xfb, 0x87, 0x7a, 0xbc, 0xf2, 0x3a, 0x38, 0xfc, 0x15, 0xc0, 0xda, 0x3b, 0x2e, 0xae, 0xce,
	0xea, 0x12, 0x47, 0x28, 0xe6, 0x97, 0x63, 0x24, 0x4f, 0x21, 0xb2, 0xfb, 0x45, 0xfe, 0x63, 0x37,
	0x16, 0x2d, 0xe9, 0x31, 0x2f, 0x1d, 0x6d, 0x91, 0xc7, 0xd0, 0xd1, 0x5b, 0x49, 0x06, 0xac, 0xb1,
	0x9c, 0x37, 0x29, 0x47, 0x30, 0x68, 0xaa, 0x48, 0x36, 0xd9, 0x3d, 0xa2, 0x26, 0x43, 0xd6, 0x5c,
	0x5e, 0xda, 0x3a, 0x08, 0xc8, 0x3e, 0xc0, 0xb2, 0x7b, 0x42, 0xee, 0x4a, 0x71, 0xe3, 0x3b, 0xe7,
	0x91, 0xf9, 0xbf, 0xbd, 0xf8, 0x13, 0x00, 0x00, 0xff, 0xff, 0x4e, 0x1e, 0x31, 0x76, 0xed, 0x04,
	0x00, 0x00,
}
